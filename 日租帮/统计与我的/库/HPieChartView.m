//
//  SMRotaryWheel.m
//  RotaryWheelProject
//
//  Created by cesarerocchi on 2/10/12.
//  Copyright (c) 2012 studiomagnolia.com. All rights reserved.

#import "HPieChartView.h"
#import <QuartzCore/QuartzCore.h>

#pragma mark PieChart

@interface BNPieChart : UIView {
@private
	
	// Variables useful for drawing.  (Avoid recomputing them too much.)
	CGFloat centerX;
	CGFloat centerY;
	CGFloat radius;
    
    // strong [All objects are retained.]
	
	// Each element is an NSNumber representing a float.
	// The values add up to 1.0.
	NSMutableArray* slicePortions;	
	
	// Endpoints of the slices.  Always has size one more than slicePortions.
	NSMutableArray* slicePointsIn01;
	
	NSMutableArray* sliceNames;
	NSMutableArray* nameLabels;
    

    // Has BNColor elements.  If #slices > #colors, the colors cycle.
    // When nil (default), uses autogenerated colors and never cycles.
    NSArray *colors;
	
	CGColorSpaceRef colorspace;
	
	int fontSize;
    

}

@property (nonatomic, retain) NSMutableArray* slicePortions;
@property (nonatomic, retain) NSArray *colors;



// Adds a slice with the given portion (fraction in the range 0.0-1.0),
// and name.  The name may be nil.
- (void)addSlicePortion:(float)slicePortion withName:(NSString *)name;

// Creates a sample pie chart in the given frame.
+ (BNPieChart *)pieChartSampleWithFrame:(CGRect)frame;

@end


// This determines the distance between the pie chart and the labels,
// or the frame, if no labels are present.
// Examples: if this is 1.0, then they are flush, if it's 0.5, then
// the pie chart only goes halfway from the center point to the nearest
// label or edge of the frame.
#define kRadiusPortion 0.92

#define nFloat(x) [NSNumber numberWithFloat:x]

// Declare private methods.
@interface BNPieChart ()

- (void)initInstance;
- (void)drawSlice:(int)index inContext:(CGContextRef)context;
- (CGGradientRef)newGradientForIndex:(int)index;
- (void)addLabelForLastName;
- (void)getRGBForIndex:(int)index red:(float *)red green:(float *)green blue:(float *)blue;
- (float)approxDistFromCenter:(CGRect)rect;
- (void)moveInLabel:(int)index;
- (void)movePreviousLabelsIn;
- (float)pointAtIndex:(int)index;

@end



@implementation BNPieChart

@synthesize slicePortions, colors;

//+ (BNPieChart *)pieChartSampleWithFrame:(CGRect)frame {
//	BNPieChart *chart = [[[BNPieChart alloc]
//                          initWithFrame:frame] autorelease];
//	[chart addSlicePortion:0.1 withName:@"Orange"];
//	[chart addSlicePortion:0.2 withName:@"Fandango"];
//	[chart addSlicePortion:0.1 withName:@"Blue"];
//	[chart addSlicePortion:0.1 withName:@"Cerulean"];
//	[chart addSlicePortion:0.3 withName:@"Green"];
//	[chart addSlicePortion:0.1 withName:@"Yellow"];
//	[chart addSlicePortion:0.1 withName:@"Pink"];
//	return chart;
//}

- (id)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        [self initInstance];
        self.frame = frame;    
    }
    return self;
}

- (id)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super initWithCoder:aDecoder]) {
        [self initInstance];
    }
    return self;
}



- (void)setFrame:(CGRect)frame {
    [super setFrame:frame];
    
    fontSize = frame.size.width / 13;
    if (fontSize < 9) fontSize = 9;
    
    // Compute the center & radius of the circle.
    centerX = frame.size.width/2;
    centerY = frame.size.height/2;
    radius = centerX < centerY ? centerX : centerY;
    radius *= kRadiusPortion;
    [self setNeedsDisplay];
}

- (void)addSlicePortion:(float)slicePortion withName:(NSString *)name {
	[sliceNames addObject:(name ? name : @"")];
    [slicePortions addObject:nFloat(slicePortion)];
	float sumSoFar = [self pointAtIndex:-1];
	[slicePointsIn01 addObject:nFloat(sumSoFar + slicePortion)];
	[self addLabelForLastName];
}

- (void)drawRect:(CGRect)rect {
	if ([slicePortions count] == 0) {
		NSLog(@"%s -- called with no slicePortions data", __FUNCTION__);
		return;
	}
    
	// Draw a white background for the pie chart.
	// We need to do this since many of our color components have alpha < 1.
	CGContextRef context = UIGraphicsGetCurrentContext();
	CGContextBeginPath(context);
	CGContextAddArc(context, centerX, centerY, radius, 0, 2*M_PI, 1);
	CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
	CGContextFillPath(context);
    
    CGContextSaveGState(context);
//    float shadowSize = radius / 15.0;
//	CGContextSetShadow(context, CGSizeMake(shadowSize, shadowSize), shadowSize);
    CGContextBeginTransparencyLayer(context, NULL);
    for (int i = 0; i < [slicePortions count]; ++i) {
        [self drawSlice:i inContext:context];
    }
    CGContextEndTransparencyLayer(context);
    CGContextRestoreGState(context);
	/*
     // Draw the glare.
	CGContextBeginPath(context);
	CGContextAddArc(context, centerX, centerY, radius, 0, 2*M_PI, 1);
	CGContextClip(context);
	CGContextBeginPath(context);
	CGContextAddArc(context, centerX - radius * 0.5, centerY - radius * 0.5,
					radius * 1.1, 0, 2*M_PI, 1);
	CGContextClip(context);
	
	// Set up the gradient for the glare.
	size_t num_locations = 2;
	CGFloat locations[2] = {0.0, 1.0};
	CGFloat components[8] = {1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.45};
	CGGradientRef gradient = CGGradientCreateWithColorComponents(colorspace, components,
																 locations, num_locations);
	CGContextDrawLinearGradient(context, gradient,
								CGPointMake(centerX + radius * 0.6, centerY + radius * 0.6),
								CGPointMake(centerX - radius, centerY - radius), 0);
	CGGradientRelease(gradient);
     */
}


#pragma mark private methods

- (void)initInstance {
    // Initialization code
    self.backgroundColor = [UIColor clearColor];
    self.opaque = NO;
    self.slicePortions = [NSMutableArray new];
    slicePointsIn01 = [[NSMutableArray alloc]
                       initWithObjects:nFloat(0.0), nil];
    sliceNames = [NSMutableArray new];
    nameLabels = [NSMutableArray new];
    colorspace = CGColorSpaceCreateDeviceRGB();    
}

- (void)drawSlice:(int)index inContext:(CGContextRef)context {
    
	CGFloat startAngle = 2 * M_PI * [self pointAtIndex:index];
	CGFloat endAngle = 2 * M_PI * [self pointAtIndex:(index + 1)];
	
	CGMutablePathRef path = CGPathCreateMutable();
	CGPathAddArc(path, NULL, centerX, centerY, radius, startAngle, endAngle, 0);
	CGPathAddLineToPoint(path, NULL, centerX, centerY);
	CGPathCloseSubpath(path);
	
	// Draw the shadowed slice.
	CGContextSaveGState(context);
	CGContextAddPath(context, path);
	CGFloat red, green, blue;
	[self getRGBForIndex:index red:&red green:&green blue:&blue];
	CGContextSetRGBFillColor(context, red, green, blue, 0.35);
	CGContextFillPath(context);
	CGContextRestoreGState(context);
    ////	
	// Draw the left-right gradient.
	CGContextSaveGState(context);
	CGContextAddPath(context, path);
	CGContextClip(context);
	CGGradientRef gradient = [self newGradientForIndex:index];
	CGContextDrawLinearGradient(context, gradient,
                                CGPointMake(centerX + radius, centerY),
                                CGPointMake(centerX - radius, centerY), 0);
	CGGradientRelease(gradient);
	CGContextRestoreGState(context);
    //	
	// Draw the slice outline.
	CGContextSaveGState(context);
	CGContextAddPath(context, path);
	CGContextClip(context);
	CGContextAddPath(context, path);
	CGContextSetLineWidth(context, 0.5);
	UIColor* darken = [UIColor colorWithWhite:0.0 alpha:0.2];
	CGContextSetStrokeColorWithColor(context, darken.CGColor);
	CGContextStrokePath(context);
	CGContextRestoreGState(context);
	
	CGPathRelease(path);
}

- (CGGradientRef)newGradientForIndex:(int)index {
	size_t num_locations = 2;
	CGFloat locations[2] = {0.0, 1.0};
	CGFloat red, green, blue;
	[self getRGBForIndex:index red:&red green:&green blue:&blue];
	CGFloat components[8] = {red, green, blue, 0.9,
        sqrt(red), sqrt(green), sqrt(blue), 0.15};
	return CGGradientCreateWithColorComponents(colorspace, components,
                                               locations, num_locations);
}

- (void)addLabelForLastName {	
    if ([[sliceNames lastObject] length] == 0) {
		//[nameLabels addObject:[NSNull null]];
		return;
	}
    
	NSString* text = [sliceNames lastObject];
	CGSize textSize = [text sizeWithFont:[UIFont boldSystemFontOfSize:fontSize]];
    
	// Find the angle of the relevant corners.
	float cornerDist[2] = {
		(self.frame.size.width - textSize.width) / 1,
		(self.frame.size.height - textSize.height) / 1};////// 圆形图的大小   圆形图的大小  圆形图的大小
    
	float cornerAngles[4];
	cornerAngles[0] = atan2(cornerDist[1], cornerDist[0]);
	cornerAngles[1] = M_PI - cornerAngles[0];
	cornerAngles[2] = cornerAngles[0] + M_PI;
	cornerAngles[3] = cornerAngles[1] + M_PI;
    
	// Find out which wall the center ray will hit.
	int index = [slicePortions count] - 1;
	float rayAngle = ([self pointAtIndex:index] +
					  [self pointAtIndex:(index + 1)]) * M_PI;
	int i;
	for (i = 0; i < 4 && rayAngle > cornerAngles[i]; ++i);
	i = i % 4;  // i might end up as 4 out of the loop
	
	// Find the hit point.  This is the point where the ray hits the frame, inset
	// by half of textSize.  It's the farthest away we can put the center of the
	// text while keeping it within frame and along the ray central to this slice.
	float hitPoint[2];
	float dist = (i % 2 == 0 ? cornerDist[0] : cornerDist[1]);
	if (i > 1) dist *= -1;
	hitPoint[i % 2] = dist;
	float delta[2] = {cos(rayAngle), sin(rayAngle)};
	float t = dist / delta[i % 2];
	hitPoint[1 - (i % 2)] = t * delta[1 - (i % 2)];
	
	int hitOriginX = hitPoint[0] + centerX - textSize.width / 2;
	int hitOriginY = hitPoint[1] + centerY - textSize.height / 2;
	
	// Set up the UILabel for this text.
	UILabel* label = [[UILabel alloc] initWithFrame:CGRectMake(hitOriginX, hitOriginY,
															   textSize.width, textSize.height)];
	label.font = [UIFont boldSystemFontOfSize:fontSize];
	label.text = text;
	CGFloat red, green, blue;
	[self getRGBForIndex:index red:&red green:&green blue:&blue];
    float darkenFactor = 0.87;  // Closer to 0 = closer to black.
    red *= darkenFactor;
    green *= darkenFactor;
    blue *= darkenFactor;
	label.textColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];/////// 百分百的颜色
	label.backgroundColor = [UIColor clearColor];
	[nameLabels addObject:label];////namelables 是数组  lable颜色的数组
	[self addSubview:label];
//	[label release];
	
	// Reposition the labels and/or resize the radius as needed to fit.
	float labelDist = [self approxDistFromCenter:label.frame];
	if (labelDist < radius / kRadiusPortion) {
		radius = labelDist * kRadiusPortion;
		[self movePreviousLabelsIn];
	} else {
		[self moveInLabel:index];
	}
}

///百分比的颜色
- (void)getRGBForIndex:(int)index red:(float *)red green:(float *)green blue:(float *)blue {
    //  if (colors) {
    //    BNColor *color = [colors objectAtIndex:(index % [colors count])];
    //    *red = color.red;
    //    *green = color.green;
    //    *blue = color.blue;
    //    return;
    //  }
//    int i = 6 - index;
//	*red = 0.5 + 0.5 * cos(i);
//	*green = 0.5 + 0.5 * sin(i);
//	*blue = 0.5 + 0.5 * cos(1.5 * i + M_PI / 4.0);



    if(index == 0){
        *red = 147.0/255;
        *green = 170.0/255;
        *blue = 235.0/255;
    }
    if(index == 1){
        *red = 68.0/255;
        *green = 203.0/255;
        *blue = 204.0/255;
    }
    if(index == 2){
        *red = 78.0/255;
        *green = 172.0/255;
        *blue = 37.0/255;
    }
    if(index == 3){
        *red = 246.0/255;
        *green = 167.0/255;
        *blue = 32.0/255;
    }
    if(index == 4){
        *red = 118.0/255;
        *green = 227.0/255;
        *blue = 172.0/255;
    }
    if(index == 5){
        *red = 211.0/255;
        *green = 33.0/255;
        *blue = 32.0/255;
    }
}

float dist(float x1, float y1, float x2, float y2) {
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

- (float)approxDistFromCenter:(CGRect)rect {
	float x = rect.origin.x;
	float y = rect.origin.y;
    
	float distance = dist(x, y, centerX, centerY);
	x += rect.size.width;
	float d = dist(x, y, centerX, centerY);
	if (d < distance) distance = d;
	y += rect.size.height;
	d = dist(x, y, centerX, centerY);
	if (d < distance) distance = d;
	x -= rect.size.width;
	d = dist(x, y, centerX, centerY);
	if (d < distance) distance = d;
	return distance;
}

- (void)moveInLabel:(int)index {
	float outerRadius = radius / kRadiusPortion;
	UILabel* label = [nameLabels objectAtIndex:index];
	float distance = [self approxDistFromCenter:label.frame];
	float excessDist = distance - outerRadius;
	if (excessDist < 5.0) return;
	float rayAngle = ([self pointAtIndex:index] +
					  [self pointAtIndex:(index + 1)]) * M_PI;
	label.frame = CGRectOffset(label.frame,
							   (int)(-cos(rayAngle) * excessDist),
							   (int)(-sin(rayAngle) * excessDist));	
}

- (void)movePreviousLabelsIn {
//	for (int index = 0; index < [slicePortions count] - 1; ++index) {
//		[self moveInLabel:index];
//	}
}

- (float)pointAtIndex:(int)index {
	index = (index + [slicePointsIn01 count]) % [slicePointsIn01 count];
	return [(NSNumber*)[slicePointsIn01 objectAtIndex:index] floatValue];
}

@end



#pragma mark Piechart





#define RADIANS_TO_DEGREES(radians) ((radians) * (180.0 / M_PI))
#define DEGREES_TO_RADIANS(angle) ((angle) / 180.0 * M_PI)


static float deltaAngle;


@implementation HPieChartView

@synthesize startTransform, container, cloves, wheelCenter;
@synthesize pie;
@synthesize pie_soon;
@synthesize array_color;

              
- (id) initWithFrame:(CGRect)frame withNum:(int)num withArray:(NSMutableArray *)array {
    
    if ((self = [super initWithFrame:frame])) {
        cloves = [[NSMutableArray alloc] initWithCapacity:num];
        self.pie = array;
		[self initWheel];
        
	}
    return self;
}

//////////////////////////////////饼形图的加载    饼形图的加载   饼形图的加载   已修改   已修改   已修改
- (void) initWheel {
    NSMutableArray *title_info;
    NSMutableArray *info;
    NSMutableArray *finish_stt;
    container = [[UIView alloc] initWithFrame:self.frame];
    
    // Calculate angle between each clove
    BNPieChart* chart = [[BNPieChart alloc] initWithFrame:CGRectMake(0.0, 0.0, 200.0, 200.0)];
//    for (int i = 0; i<[pie count]; i++){
//        if(i == 0){
//            title_info = [NSMutableArray array];
//            info = [NSMutableArray array];
//        }
//        NSString *ss = pie[i];
//        NSString *sss = [ss substringWithRange:NSMakeRange(2, 2)];
//        NSString *s = [sss stringByAppendingString:@"%"];
//        [title_info addObject:s];
//        
//    }
    NSLog(@"%@",pie);
    //解析颜色数组
    for (NSDictionary *dic_color in pie) {
        NSString *num_color = [NSString stringWithFormat:@"%@",dic_color[@"color"]];
        [array_color addObject:num_color];
    }
    
    
    if(!info){
        info = [NSMutableArray array];
    }
    for (NSDictionary *dic in pie) {
        NSString *num = [NSString stringWithFormat:@"%@",dic[@"percent"]];
        [info addObject:num];
    }
    int sum = 0;
    for (NSString *str in info) {
        sum = sum + [str integerValue];
    }
    if(!title_info){
        title_info = [NSMutableArray array];
    }
    for(int i = 0;i <info.count;i++){
        float k = [info[i]floatValue];
        float aa = k/sum;
        NSString *bb = [NSString stringWithFormat:@"%0.2f",aa];
        [title_info addObject:bb];
    }
    pie_soon = title_info;
    NSLog(@"%@",title_info);
    
    if(!finish_stt){
        finish_stt = [NSMutableArray array];
    }
    for (NSString *stt in title_info) {
        NSString *jie = [stt substringWithRange:NSMakeRange(2, 2)];
        NSString *finish = [jie stringByAppendingString:@"%"];
        [finish_stt addObject:finish];
    }
    
    if(pie.count == 1){
        NSString  * slicePortion = @"100%";
        [chart addSlicePortion:[slicePortion floatValue] withName:slicePortion];
    }
    for (int i = 0; i<[pie count]; i++) {
        
        NSString  * slicePortion = [title_info objectAtIndex:i];
        [chart addSlicePortion:[slicePortion floatValue] withName:finish_stt[i]];  // portions add to 1.0
    }


//    for (int i = 0; i<[pie count]; i++) {
//        
//        NSString  * slicePortion = [pie objectAtIndex:i];
//        [chart addSlicePortion:[slicePortion floatValue] withName:title_info[i]];  // portions add to 1.0
//    }
   // chart.layer.anchorPoint = CGPointMake(0.5f, 0.5f);
    chart.layer.position = CGPointMake(container.bounds.size.width/2.0,container.bounds.size.height/2.0);//饼形图的位置
    [container addSubview:chart];
    container.userInteractionEnabled = NO;
    [self addSubview:container];
    [self buildClovesOdd];

    
}


- (void) buildClovesOdd {
    float fanWidth;
    CGFloat min = 0;
    for (int i = 0; i<[pie count]; i++) {
        if(pie_soon.count == 1){
            int oo = [pie_soon[0]integerValue];
            NSString *pp = [NSString stringWithFormat:@"%d",oo *100];
            pie_soon = [NSMutableArray array];
            [pie_soon addObject:pp];
           NSString  * slicePortion = [pie_soon objectAtIndex:i];
             fanWidth = M_PI*2*[slicePortion floatValue];
        }else{
        NSString  * slicePortion = [pie_soon objectAtIndex:i];
             fanWidth = M_PI*2*[slicePortion floatValue];
        }
        
        
        SMClove * clove = [[SMClove alloc] init];
        
        clove.minValue = min;
        clove.midValue = min + fanWidth /2;
        clove.maxValue = min + fanWidth;
        min += fanWidth;
        NSLog(@"cl is mid=%f min=%f max=%f", clove.midValue,clove.minValue,clove.maxValue);
        [cloves addObject:clove];
    }    
    
}
/////////     停止饼形图的转动  停止饼形图的转动  停止饼形图的转动

//- (float) calculateDistanceFromCenter:(CGPoint)point {
//
//    CGPoint center = CGPointMake(self.bounds.size.width/2.0f, self.bounds.size.height/2.0f);
//	float dx = point.x - center.x;
//	float dy = point.y - center.y;
//	return sqrt(dx*dx + dy*dy);
//    
//}
//
//-(void) touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
//
//    UITouch *touch = [touches anyObject];
//    CGPoint delta = [touch locationInView:self];
//    float dist = [self calculateDistanceFromCenter:delta];
//    
//    if (dist < 40 || dist > 100) 
//    {
//        // forcing a tap to be on the ferrule
//        NSLog(@"ignoring tap (%f,%f)", delta.x, delta.y);
//        return;
//    }
//    
//    startTransform = container.transform;
//    
//    
//	float dx = delta.x  - container.center.x;
//	float dy = delta.y  - container.center.y;
//	deltaAngle = atan2(dy,dx); 
//    NSLog(@"touch begin %f",deltaAngle);
//    
//}
//
//
//
//
//- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
//{
//    UITouch *touch = [touches anyObject];
//    
//    CGPoint pt = [touch locationInView:self];
//	
//	float dx = pt.x  - container.center.x;
//	float dy = pt.y  - container.center.y;
//	float ang = atan2(dy,dx);
//    
//    float angleDif = deltaAngle - ang;
//    
//    CGAffineTransform newTrans = CGAffineTransformRotate(startTransform, -angleDif);
//    container.transform = newTrans;
//   
//}
//
//
//- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
//    
//    CGFloat radians = atan2f(container.transform.b, container.transform.a);
//    
//    CGFloat newVal = 0.0;
//    
//    
//    radians = radians > 0 ? radians : 2*M_PI + radians;
//    radians = 2 * M_PI - radians;
//    NSLog(@"%d",[cloves count]);
//    for (SMClove * c in cloves) {
//        NSLog(@"radians is %f",radians);
//        NSLog(@"c.minValue is %f",c.minValue);
//        NSLog(@"c.maxValue is %f",c.maxValue);
//        if (c.minValue< radians && radians < c.maxValue) {
//            newVal = c.midValue -radians;
//
//            NSLog(@"c.midValue is %f",c.midValue);
//            NSLog(@"newVal is %f",newVal);
//
//        }
//    }
//       
//    [UIView beginAnimations:nil context:NULL];
//    [UIView setAnimationDuration:0.5];
//    
//    CGAffineTransform t = CGAffineTransformRotate(container.transform, -newVal);
//    container.transform = t;
//    
//    [UIView commitAnimations];
//        
//}

//-(void)dealloc{
//    [cloves release];
//    [super dealloc];
//}

@end
